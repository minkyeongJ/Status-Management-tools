# 다양한 상태관리 다루기

리액트로 개발한다면 상태관리툴을 결국엔 사용하게 될 것이다. 어떤 상태관리 툴을 쓰면 좋을까? 그걸 알아보기 위해 다양한 상태관리 라이브러리를 간단하게 사용해보고자 한다.

세 종류의 아키텍쳐에서 2가지씩 선정해 사용했다.

1. 플러스 아키텍처 지향 : redux, zustand(탑다운)

2. 아토믹 아키텍처 지향: recoil, jotai(바텀업)

3. 프록시 아키텍터 지향: mobx, valtio

상태관리툴의 이름을 폴더명으로 작성하고, 그에 따라 분리하였다.
다크모드/라이트모드를 전역상태로 관리하는 기능을 공통적으로 구현하였다.

# 페이지 이동

[Redux](./Redux/)

[Zustand](./Zustand/)

[Recoil](./Recoil/)

[Jotai](./Jotai/)

[MobX](./MobX/)

[Valtio](./Valtio/)

# 아키텍쳐에 대한 개념

## 1. 플러스 아키텍처 지향

플럭스(Flux)는 Facebook에서 제안한 클라이언트-사이드 애플리케이션 아키텍처입니다. 플럭스는 단방향 데이터 흐름을 사용하여 애플리케이션의 상태를 관리합니다. Redux는 이 플럭스 아키텍처를 따르는 대표적인 예입니다. Redux에서는 액션(action), 액션 생성자(action creator), 리듀서(reducer), 스토어(store)라는 개념을 사용하여 상태를 관리합니다. 이 방식은 상태 업데이트의 예측가능성과 추적 가능성을 높이는 데 유용합니다.

1. 액션(Action): 액션은 애플리케이션에서 발생하는 각 이벤트를 나타내는 단순한 자바스크립트 객체입니다. 액션의 기본 구조는 'type' 필드를 반드시 포함하며, 이는 액션의 종류를 정의합니다. 추가적인 필드로는 액션과 관련된 데이터를 추가로 포함할 수 있습니다.

2. 액션 생성자(Action Creator): 액션 생성자는 액션을 생성하는 함수입니다. 이 함수는 보통 'dispatch'라는 메서드를 사용하여 스토어에 액션을 보냅니다. 액션 생성자는 사용자 인터페이스와 같이 액션을 발생시키는 컴포넌트에서 호출됩니다.

3. 리듀서(Reducer): 리듀서는 액션을 받아 애플리케이션의 상태를 변경하는 함수입니다. 리듀서는 순수 함수로, 이전 상태와 액션을 인수로 받아 새로운 상태를 반환합니다. 리듀서는 'type' 필드를 사용하여 액션의 종류를 확인하고, 이에 따라 상태를 변경합니다.

4. 스토어(Store): 스토어는 애플리케이션의 상태를 보관하는 객체입니다. 스토어는 액션을 받아 리듀서를 호출하고, 리듀서에 의해 반환된 새로운 상태를 저장합니다. 또한, 스토어는 애플리케이션의 상태가 변경될 때마다 이를 구독하고 있는 컴포넌트에게 알립니다.

플럭스 아키텍처의 핵심 개념은 '단방향 데이터 흐름'입니다. 이는 액션 생성자가 액션을 생성하고 스토어로 보내고, 스토어가 리듀서를 호출하여 상태를 변경하고, 변경된 상태가 다시 애플리케이션으로 흐르는 과정을 의미합니다. 이런 방식으로 플럭스는 애플리케이션의 상태 관리를 간단하고 예측 가능하게 만들어 줍니다.

## 2. 아토믹 아키텍처 지향

아토믹 상태 관리는 상태를 최소 단위로 분리하여 관리하는 방식입니다. Recoil과 Jotai가 대표적인 예입니다. Recoil에서는 이러한 최소 단위를 '아톰(atom)'이라고 부릅니다. 아톰은 상태 조각을 나타내며, 여러 컴포넌트가 동일한 아톰을 구독(subscribe)하면, 해당 상태가 변경될 때 모든 컴포넌트가 동시에 업데이트 됩니다. 이 방식은 상태 간의 의존성을 명확하게 관리할 수 있습니다.

아토믹 디자인은 다음과 같은 5가지 구성요소로 이루어져 있습니다.

1. 원자(Atoms): 원자는 디자인 시스템의 가장 기본적인 구성요소로써, 단독으로 사용되지 않고 다른 요소와 결합하여 더 큰 기능을 구현합니다. 버튼, 레이블, 인풋 필드 등이 원자에 해당합니다.

2. 분자(Molecules): 분자는 여러 원자가 결합하여 만들어진, 의미를 가지는 작은 기능단위입니다. 예를 들어, 레이블과 인풋 필드, 버튼이 결합하면 검색 폼이라는 분자를 구성할 수 있습니다.

3. 유기체(Organisms): 유기체는 분자나 원자들이 결합하여 구성된, 보다 복잡한 인터페이스입니다. 유기체는 페이지 내에서 특정 기능을 수행합니다. 예를 들어, 헤더, 푸터, 내비게이션 바 등이 유기체에 해당합니다.

4. 템플릿(Templates): 템플릿은 유기체, 분자, 원자들이 실제 콘텐츠 없이 구조만을 정의한 것입니다. 디자인의 레이아웃을 결정하며, 어떤 컴포넌트가 어디에 위치할 지, 어떻게 작동할 지를 미리 볼 수 있게 합니다.

5. 페이지(Pages): 페이지는 템플릿에 실제 콘텐츠와 데이터가 적용된 상태입니다. 사용자에게 제공되는 최종적인 인터페이스입니다.

아토믹 디자인은 이러한 구성요소를 통해 복잡한 인터페이스도 재사용 가능한 작은 단위로 분해하고, 이를 조합하여 일관성 있는 사용자 경험을 제공하는 것을 목표로 합니다.

## 3. 프록시 아키텍터 지향

프록시 상태 관리는 JavaScript의 Proxy 객체를 활용하여 상태 변경을 감지하고 관리하는 방식입니다. Valtio와 MobX가 이 방식을 사용합니다. 프록시를 사용하면 상태 객체에 직접 접근하여 변경할 수 있으며, 이 변경을 자동으로 감지하여 관련된 컴포넌트를 렌더링합니다. 이 방식은 코드를 간결하게 유지하면서도 반응성을 높일 수 있습니다.

JavaScript의 Proxy 객체는 target 객체를 감싸 상태 변경을 감지하는 데 사용됩니다. Proxy 객체는 'handler' 객체를 사용하여 target 객체의 동작을 정의합니다. 'handler'는 trap(함정)이라는 메서드들을 포함하여 target 객체의 동작을 사용자 정의합니다.

Proxy 객체를 활용한 상태 관리 아키텍처는 대표적으로 Vue.js의 반응형 시스템에서 볼 수 있습니다. Vue.js는 Proxy 객체를 활용하여 데이터의 변경을 감지하고, 변경이 감지되면 그에 따른 UI 업데이트를 자동으로 수행합니다.

이러한 아키텍처는 상태 변경을 효과적으로 감지하고 관리하므로, 상태의 일관성을 유지하면서도 코드의 복잡성을 줄일 수 있습니다. 하지만 Proxy 객체는 ES6에서 도입되었기 때문에, ES6를 지원하지 않는 환경에서는 사용할 수 없는 단점이 있습니다.

이 외에도 Proxy 객체는 여러 가지 방식으로 활용될 수 있으므로, 상황에 따라 적절하게 활용할 수 있습니다.
